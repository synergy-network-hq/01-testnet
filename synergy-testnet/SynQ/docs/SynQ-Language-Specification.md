# SynQ Language Specification

## 1. Introduction

SynQ is a novel smart contract language designed to operate securely in a post-quantum cryptographic era. It integrates first-class support for quantum-resistant cryptographic primitives, specifically focusing on the NIST-standardized Dilithium, Falcon, and Kyber algorithms. This specification outlines the core components of SynQ, including its data types, built-in functions, and a resource-aware gas model tailored for the computational demands of post-quantum cryptography.

## 2. Data Types

SynQ introduces specialized data types to natively handle post-quantum cryptographic keys and signatures. These types are designed to be efficient and secure, reflecting the unique characteristics of PQC algorithms.

### 2.1. Post-Quantum Public Keys

Public keys for Dilithium, Falcon, and Kyber are represented by distinct types, allowing for strong type checking and ensuring compatibility with their respective signature and key encapsulation mechanisms.

*   `DilithiumPublicKey`: Represents a public key for the Dilithium digital signature scheme.
*   `FalconPublicKey`: Represents a public key for the Falcon digital signature scheme.
*   `KyberPublicKey`: Represents a public key for the Kyber Key Encapsulation Mechanism (KEM).

### 2.2. Post-Quantum Signatures

Signatures generated by Dilithium and Falcon algorithms have their own dedicated types.

*   `DilithiumSignature`: Represents a digital signature generated using the Dilithium scheme.
*   `FalconSignature`: Represents a digital signature generated using the Falcon scheme.

### 2.3. Other Primitive Types

In addition to PQC-specific types, SynQ will support standard primitive types common in smart contract languages, such as `Address`, `UInt256`, `Bool`, and `Bytes`.



## 3. Built-in Functions

SynQ provides built-in functions for verifying post-quantum signatures, ensuring that cryptographic operations are performed correctly and efficiently within the smart contract environment. These functions are optimized for the underlying PQC algorithms.

### 3.1. Signature Verification

*   `verifyDilithiumSignature(publicKey: DilithiumPublicKey, message: Bytes, signature: DilithiumSignature): Bool`
    *   Verifies a Dilithium signature against a message and public key. Returns `true` if the signature is valid, `false` otherwise.

*   `verifyFalconSignature(publicKey: FalconPublicKey, message: Bytes, signature: FalconSignature): Bool`
    *   Verifies a Falcon signature against a message and public key. Returns `true` if the signature is valid, `false` otherwise.

### 3.2. Key Encapsulation (Kyber)

While Kyber is a Key Encapsulation Mechanism (KEM) and not a signature scheme, its inclusion as a first-class type allows for future extensions related to secure key exchange within the SynQ ecosystem. Direct KEM operations (encapsulation/decapsulation) are typically performed off-chain, with only the resulting shared secret or public keys being used on-chain for verification or other purposes.

## 4. Resource and Gas Model

The computational complexity of post-quantum cryptographic operations is significantly higher than traditional cryptographic algorithms like ECDSA. SynQ's gas model is designed to accurately reflect these costs, preventing denial-of-service attacks and ensuring fair resource allocation.

### 4.1. Dynamic Gas Pricing for PQC Operations

Unlike fixed gas costs for basic operations, PQC operations will have dynamic gas pricing based on the computational resources consumed. This includes factors such as:

*   **Key Size:** Larger key sizes (e.g., Dilithium5 vs. Dilithium2) will incur higher gas costs.
*   **Signature Size:** The size of the signature directly impacts the verification cost.
*   **Algorithm Complexity:** Different PQC algorithms have varying computational complexities, which will be reflected in their gas costs.

### 4.2. Gas Cost Components

The gas cost for PQC operations will be composed of:

*   **Base Cost:** A fixed cost for initiating the PQC operation.
*   **Data Processing Cost:** A cost proportional to the size of the public key, message, and signature.
*   **Computational Cost:** A cost reflecting the actual CPU cycles and memory usage required for the cryptographic computation.

This detailed gas model ensures that the network remains secure and economically viable even with the integration of computationally intensive PQC algorithms. Specific gas values will be determined through extensive benchmarking and network consensus, similar to how gas costs are established in existing blockchain platforms.



## 5. Example Syntax: PQC-Verified DAO Contract

This section provides an example of a simplified Decentralized Autonomous Organization (DAO) contract written in SynQ, demonstrating the use of post-quantum cryptographic types and functions for secure proposal voting and execution. In this DAO, critical actions, such as executing a proposal, require a signature verified by a Dilithium public key held by a designated 'governance' multisig or a set of trusted parties.

```quantumscript
// Define a structure for proposals
struct Proposal {
    UInt256 id;
    Address proposer;
    Bytes  description;
    Bool   executed;
    UInt256  votesFor;
    UInt256  votesAgainst;
}

// Define the DAO contract
contract PQCVerifiedDAO {

    // State variables
    Address public owner;
    DilithiumPublicKey public governanceKey; // Public key for PQC-verified governance actions
    mapping(UInt256 => Proposal) public proposals;
    UInt256 public nextProposalId;

    // Events
    event ProposalCreated(UInt256 indexed id, Address indexed proposer);
    event Voted(UInt256 indexed proposalId, Address indexed voter, Bool support);
    event ProposalExecuted(UInt256 indexed id);

    // Constructor: Sets the contract owner and the initial governance public key
    constructor(DilithiumPublicKey _governanceKey) {
        owner = msg.sender;
        governanceKey = _governanceKey;
        nextProposalId = 1;
    }

    // Function to create a new proposal
    function createProposal(Bytes _description) public returns (UInt256) {
        UInt256 proposalId = nextProposalId;
        proposals[proposalId] = Proposal({
            id: proposalId,
            proposer: msg.sender,
            description: _description,
            executed: false,
            votesFor: 0,
            votesAgainst: 0
        });
        nextProposalId += 1;
        emit ProposalCreated(proposalId, msg.sender);
        return proposalId;
    }

    // Function to vote on a proposal
    function vote(UInt256 _proposalId, Bool _support) public {
        require(proposals[_proposalId].id != 0, "Proposal does not exist");
        // In a real DAO, more complex voting logic would be here (e.g., one vote per address, token-weighted voting)
        if (_support) {
            proposals[_proposalId].votesFor += 1;
        } else {
            proposals[_proposalId].votesAgainst += 1;
        }
        emit Voted(_proposalId, msg.sender, _support);
    }

    // Function to execute a proposal, requiring a PQC signature
    function executeProposal(
        UInt256 _proposalId,
        Bytes _messageToSign, // The message that was signed (e.g., proposalId + action details)
        DilithiumSignature _signature
    ) public {
        require(proposals[_proposalId].id != 0, "Proposal does not exist");
        require(!proposals[_proposalId].executed, "Proposal already executed");

        // Verify the Dilithium signature using the stored governance public key
        // The _messageToSign would typically include the proposal ID and the intended action
        Bool isValidSignature = verifyDilithiumSignature(
            governanceKey,
            _messageToSign,
            _signature
        );

        require(isValidSignature, "Invalid PQC governance signature");

        // Example: Simple majority vote for execution
        require(proposals[_proposalId].votesFor > proposals[_proposalId].votesAgainst, "Proposal not approved by majority");

        // Mark proposal as executed and perform the action (e.g., call another contract, change state)
        proposals[_proposalId].executed = true;
        // <DAO specific action would go here>
        emit ProposalExecuted(_proposalId);
    }

    // Function to update the governance key (requires existing governance key signature)
    function updateGovernanceKey(
        DilithiumPublicKey _newGovernanceKey,
        Bytes _messageToSign,
        DilithiumSignature _signature
    ) public {
        // This function itself would need to be callable only by the current governance key
        // For simplicity, we assume 'owner' can call it, but in a real PQC DAO, this would be a proposal
        // that gets executed after PQC verification.

        Bool isValidSignature = verifyDilithiumSignature(
            governanceKey,
            _messageToSign,
            _signature
        );
        require(isValidSignature, "Invalid PQC signature for governance key update");

        governanceKey = _newGovernanceKey;
    }
}
```

### Explanation of PQC Elements in the DAO Contract:

*   **`DilithiumPublicKey public governanceKey;`**: A state variable to store the Dilithium public key that is authorized to sign critical governance actions. This key would typically belong to a multi-signature wallet or a set of highly trusted individuals/entities.
*   **`constructor(DilithiumPublicKey _governanceKey)`**: The constructor initializes the DAO with the designated Dilithium public key.
*   **`executeProposal(...)` function**: This function is central to the DAO's operation. Before a proposal can be executed, it requires a valid Dilithium signature. The `verifyDilithiumSignature` built-in function is used to check the authenticity of this signature against the `governanceKey`.
*   **`updateGovernanceKey(...)` function**: This function demonstrates how the `governanceKey` itself could be updated, again requiring a valid signature from the *current* `governanceKey` to prevent unauthorized changes. In a more robust DAO, this update would likely be part of a proposal that goes through the voting process.

This example illustrates how SynQ's native support for PQC types and verification functions enables the creation of smart contracts that are resilient to quantum attacks, particularly for critical on-chain governance mechanisms.
